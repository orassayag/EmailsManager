
/* ScriptName, */
/* const ScriptName = enumUtils.createEnum([
    ['CRAWL_MBOX_FILES', 'crawl-mbox-files'],
    ['SEARCH_EMAIL_ADDRESSES', 'search-email-addresses']
]); */

/* StatusIcon */
/* // This enum define the possible status icons.
const StatusIcon = enumUtils.createEnum([
    ['V', '✅'],
    ['X', '❌']
]); */

/* const settings = require('../settings/crawl-mbox-files.settings'); */
/*         (async () => { */
/*         })(); */
/*                 //this.globalSummaryData['EndDateTime'] = new Date(); */

/* const { PackageType } = require('../../../core/enums/files/system.enum'); */

/*         if (!EMAIL_VALIDATION_URL) {
            throw new Error('No EMAIL_VALIDATION_URL parameter was found (1000034)');
        } */
/*         if (!validationUtils.isValidURL(EMAIL_VALIDATION_URL)) {
            throw new Error('Invalid or no EMAIL_VALIDATION_URL parameter was found (1000035)');
        } */
/* , textUtils  */
/* emailUtils, */

/*     // Validate the test email addresses to make sure that the free validation API is available.
    async validateEmail(data) {
        const { errorCode, emailAddress, expectedResult } = data;
        if (expectedResult !== await emailUtils.validateServerEmailAddressFree(emailAddress)) {
            throw new Error(`The free API email validator has failed to validate ${emailAddress} (${errorCode})`);
        }
    } */

    /*         // Validate the test email addresses to make sure that the free validation API is available.
        await this.validateEmail({
            errorCode: 1000035,
            emailAddress: 'test@gmail.com',
            expectedResult: true
        });
        await this.validateEmail({
            errorCode: 1000036,
            emailAddress: 'this-is-not-an-email-address',
            expectedResult: false
        }); */

        /* const { PackageType } = require('../../../core/enums/files/system.enum'); */

        /* const { Color } = require('../core/enums/files/text.enum'); */
        /*         console.log(1); */
/*         console.log(2); */
/*         console.log(3); */
/*         if (this.backupData.targetBackupName.length <= 0) {
            throw new Error('Invalid backup name length was provided (1000002)');
        } */

        /*     // ===URL=== //
    EMAIL_VALIDATION_URL: 'https://www.emailitin.com/email_validator', */

    /* sourceUtils, */
/* const sourceUtils = require('./files/source.utils'); */

/*         console.log(targetPath);
        console.log(fileEmailAddressesList); */
    //validateServerEmailAddressFree()
/* const emailUtils = new EmailUtils();
module.exports = emailUtils; */

/* const request = require('request');
const settings = require('../../settings/crawl-mbox-files.settings'); */
/*     async validateServerEmailAddressFree(emailAddress) {
        return new Promise(resolve => {
            if (!emailAddress) {
                resolve(false);
            }

            try {
                request({
                    url: settings.EMAIL_VALIDATION_URL,
                    method: 'POST',
                    form: { email: emailAddress },
                    json: true
                }, (error, response, body) => {
                    if (response) { }
                    if (error) {
                        resolve(false);
                    }
                    else if (!body) {
                        resolve(false);
                    }
                    else if (!body.valid) {
                        resolve(false);
                    }
                    else {
                        resolve(true);
                    }
                });
            }
            catch (error) {
                resolve(false);
            }
        });
    } */


//================================

/* const fs = require('fs-extra');

class FileUtils {

    constructor() { }

    async read(targetPath) {
        return await fs.readFile(targetPath, 'utf-8');
    }

    async isPathExists(targetPath) {
        // Check if the path parameter was received.
        if (!targetPath) {
            throw new Error(`targetPath not received: ${targetPath} (1000030)`);
        }
        // Check if the path parameter exists.
        try {
            return await fs.stat(targetPath);
        }
        catch (error) {
            return false;
        }
    }

    // This method check if a receive target path is accessible.
    async isPathAccessible(targetPath) {
        // Verify that the path exists.
        await this.isPathExists(targetPath);
        // Check if the path is readable.
        if (await fs.access(targetPath, fs.constants.R_OK)) {
            throw new Error(`targetPath not readable: ${targetPath} (1000002)`);
        }
        // Check if the path is writable.
        if (await fs.access(targetPath, fs.constants.W_OK)) {
            throw new Error(`targetPath not writable: ${targetPath} (1000003)`);
        }
    }

    // This method remove all files from a given target path.
    async emptyDirectory(targetPath) {
        // Verify that the path exists.
        globalUtils.isPathExistsError(targetPath);
        // Empty the directory.
        await fs.emptyDir(targetPath);
    }

    // This method return all the files in a given target path.
    async getDirectoryFiles(targetPath) {
        // Verify that the path exists.
        globalUtils.isPathExistsError(targetPath);
        // Get all the files.
        return await fs.readdir(targetPath);
    }

    // This method return the file size.
    async getFileSize(targetPath) {
        // Verify that the path exists.
        globalUtils.isPathExistsError(targetPath);
        // Return file size.
        return (await fs.stat(targetPath)).size;
    }

    async readFile(targetPath) {
        // Verify that the path exists.
        globalUtils.isPathExistsError(targetPath);
        // Return the file content.
        return await this.read(targetPath);
    }

    async removeFileIfExists(targetPath) {
        // Check if the file exists.
        if (await this.isPathExists(targetPath)) {
            // Remove it.
            await fs.unlink(targetPath);
        }
    }

    async createDirectoryIfNotExists(targetPath) {
        if (!        globalUtils.isPathExistsError(targetPath);) {
            await fs.mkdir(targetPath);
        }
    }

    async appendFile(data) {
        const { targetPath, message } = data;
        if (!targetPath) {
            throw new Error(`targetPath not found: ${targetPath} (1000058)`);
        }
        if (!message) {
            throw new Error(`message not found: ${message} (1000018)`);
        }
        // Append the message to the file.
        await fs.appendFile(targetPath, message);
    }

    async renameFile(data) {
        const { basePath, targetPath } = data;
        if (!basePath) {
            throw new Error(`basePath not found: ${basePath} (1000059)`);
        }
        if (!targetPath) {
            throw new Error(`targetPath not found: ${targetPath} (1000019)`);
        }
        // Verify that the base path exists.
        globalUtils.isPathExistsError(targetPath);
        // Rename the path.
        await fs.rename(basePath, targetPath);
    }

    async getFileLinesCount(targetPath) {
        // Verify that the path exists.
        globalUtils.isPathExistsError(targetPath);
        return new Promise(resolve => {
            let i;
            let count = 0;
            fs.createReadStream(targetPath)
                .on('data', (chunk) => {
                    for (i = 0; i < chunk.length; ++i) {
                        if (chunk[i] === 10) {
                            count++;
                        }
                    }
                })
                .on('end', () => {
                    resolve(count);
                });
        });
    }

    async removeFile(targetPath) {
        // Verify that the path exists.
        globalUtils.isPathExistsError(targetPath);
        // Remove the file.
        await fs.unlink(targetPath);
    }

    isDirectoryPath(path) {
        const stats = fs.statSync(path);
        return stats.isDirectory();
    }
}

const fileUtils = new FileUtils();
module.exports = fileUtils; */

/*     // This method check if a receive target path is exist.
    async isPathExists(targetPath) {
        // Check if the path parameter was received.
        if (!targetPath) {
            throw new Error(`targetPath not received: ${targetPath} (1000000)`);
        }

        // Check if the path parameter exists.
        if (!await fs.exists(targetPath)) {
            throw new Error(`targetPath not exists: ${targetPath} (1000001)`);
        }
    } */

    /* const pathUtils = new PathUtils();
module.exports = pathUtils; */

/* const systemUtils = new SystemUtils();
module.exports = systemUtils; */

/*     async sleep(secondsCount) {
        if (!validationUtils.isValidNumber(secondsCount)) {
            return;
        }
        return new Promise(resolve => setTimeout(resolve, secondsCount * 1000));
    } */

    /* const timeUtils = new TimeUtils();
module.exports = timeUtils; */

/*     isValidURL(URLAddress) {
        // ToDo: Move to regex utils.
        return this.URLAddressRegex.test(URLAddress);
    }

    isValidMongoConnectionString(mongoConnectionString) {
        // ToDo: Move to regex utils.
        return this.MongoConnectionStringRegex.test(mongoConnectionString);
    } */
/* const validationUtils = new ValidationUtils();
module.exports = validationUtils; */
/*         // ToDo: Build a file that will contain all regex expressions,
        // and for each it will has regular expression tester method.
        // ToDo: Move to regex utils.
        this.URLAddressRegex = new RegExp('^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.?)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$', 'i');
        this.MongoConnectionStringRegex = new RegExp('^(mongodb:\/{2})localhost:(\d*)\/?(.*)'); */

        /* const colorUtils = new ColorUtils();
module.exports = colorUtils; */
/* const { ColorCode } = require('../../core/enums/files/text.enum'); */

/* const logUtils = new LogUtils();
module.exports = logUtils; */
/* const { Color } = require('../../core/enums/files/text.enum'); */

/* const streamUtils = new StreamUtils();
module.exports = streamUtils; */
/* const { PackageType } = require('../../core/enums/files/system.enum'); */

/* systemUtils, */
/*             await systemUtils.sleep(this.secondsDelayBetweenValidations); */
/*     async validateAllEmailAddresses() {
        const emailAddressesList = await emailUtils.getEmailAddressesFromFile(this.file.distFinalMergeViewTXTFile.filePath);
        for (let i = 0, length = emailAddressesList.length; i < length; i++) {
            await systemUtils.sleep(this.secondsDelayBetweenValidations);
            await this.validateEmailAddress(i + 1, emailAddressesList[i], emailAddressesList.length);
        }
    } */

/*     async validateEmailAddress(index, emailAddress, totalEmailAddressesCount) {
        let isValid = true;
        const emailAddresses = textUtils.getEmailAddresses(emailAddress);
        if (!validationUtils.isExists(emailAddresses)) {
            isValid = false;
        }
        if (isValid) {
            isValid = await emailUtils.validateServerEmailAddressFree(emailAddress);
        }
        if (isValid) {
            this.validEmailAddressesList.push(emailAddress);
        }
        else {
            this.invalidEmailAddressesList.push(emailAddress);
        }
        // Log the progress.
        logUtils.logSpace();
        logUtils.logProgress({
            progressData: {
                'Index': `${textUtils.getNumberWithCommas(index)}/${textUtils.getNumberWithCommas(totalEmailAddressesCount)}`,
                'Email': textUtils.verifyCharactersLength({
                    value: emailAddress,
                    maximumCharactersLength: this.maximumEmailCharactersLength
                }),
                'Valid': isValid ? 'Yes' : 'No',
                'Valid email addresses': this.validEmailAddressesList.length,
                'Invalid email addresses': this.invalidEmailAddressesList.length
            },
            percentage: textUtils.calculateParentageDisplay({
                partialValue: index,
                totalValue: totalEmailAddressesCount
            })
        });
    } */

    // Find a way to merge into one method, this is duplicate logic (already built, check it).
    // Check if this is working with appropriate internet connection.
    /*     async appendEmailAddress(data) {
            const { file, emailAddressesList } = data;
            await fileUtils.appendFile({
                targetPath: file.filePath,
                message: textUtils.breakLine(emailAddressesList)
            });
            await file.calculateFileSize();
            file.fileEmailAddressesCount = emailAddressesList.length;
        }

        async appendFiles() {
            // Valid email addresses.
            await this.appendEmailAddress({
                file: this.file.distFinalValidTXTFile,
                emailAddressesList: this.validEmailAddressesList
            });

            // Invalid email addresses.
            await this.appendEmailAddress({
                file: this.file.distFinalInvalidTXTFile,
                emailAddressesList: this.invalidEmailAddressesList
            });
        } */

        /* require('../services/global/setup.service'); */

        /* const { ScriptType } = require('../../core/enums/files/system.enum'); */


/* const textUtils = new TextUtils();
module.exports = textUtils; */

/* const enumUtils = new EnumUtils();
module.exports = enumUtils; */

/* //const { CrawlData, FileData, MergeData, MergeRound, ScanData, ScanRound, SummaryData } = require('..'); */

/* const Color = require('../enums/files/system.enum')
const ColorCode
const PackageType
const ScriptType */

/*                 //new SetupService(settings).initiateSetup(); */

/* SetupService,  */
/* const SetupService = require('./files/setup.service'); */

/*     async removeFileIfExists(targetPath) {
        // Check if the file exists.
        if (await this.isPathExists(targetPath)) {
            // Remove it.
            await fs.unlink(targetPath);
        }
    } */

/*     async getFilesRecursive(directory) {
        const dirents = await fs.readdir(directory, { withFileTypes: true });
        const files = await Promise.all(dirents.map(dirent => {
            const result = pathUtils.resolve(directory, dirent.name);
            return dirent.isDirectory() ? this.getFilesRecursive(result) : result;
        }));
        return Array.prototype.concat(...files);
    } */

    /*     async isPathAccessible(targetPath) {
        // Verify that the path exists.
        await this.isPathExists(targetPath);
        // Check if the path is readable.
        if (await fs.access(targetPath, fs.constants.R_OK)) {
            throw new Error(`targetPath not readable: ${targetPath} (1000002)`);
        }
        // Check if the path is writable.
        if (await fs.access(targetPath, fs.constants.W_OK)) {
            throw new Error(`targetPath not writable: ${targetPath} (1000003)`);
        }
    } */

    /* 		this.englishLettersRegex = /^[a-zA-Z\\-]+$/; */
/* 		this.urlAddressRegex = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)?/gi; */

/*     getRandomKeyFromArray(list) {
        if (!validationUtils.isExists(list)) {
            return '';
        }
        return list[Math.floor(Math.random() * list.length)];
    } */

/*     isEnglishKey(key) {
        return this.englishLettersRegex.test(key);
    } */

/*     getDomainFromURLAddress(URLAddress) {
        if (!validationUtils.isExists(URLAddress)) {
            return '';
        }
        let domain = '';
        try {
            domain = url.parse(URLAddress.toLowerCase().trim()).hostname;
        } catch (error) {}
        // Remove the 'www' prefix if exists.
        if (domain && domain.startsWith('www')) {
            domain = domain.split('.').slice(1).join('.');
        }
        return domain;
    } */

/*     getMergedLists(data) {
        const { originalList, newList } = data;
        if (!originalList || !validationUtils.isExists(newList)) {
            return originalList;
        }
        return originalList.concat(newList);
    } */

    /*     getSeconds(date) {
        return textUtils.addLeadingZero(date.getSeconds());
    } */

/*     getMinutes(date) {
        return textUtils.addLeadingZero(date.getMinutes());
    } */

/*     getHours(date) {
        return textUtils.addLeadingZero(date.getHours());
    } */

    /*     getURLAddresses(data) {
        if (!validationUtils.isExists(data)) {
            return [];
        }
        return data.toString().match(regexUtils.urlAddressRegex);
    }
 */

 /*     // This method checks if a given variable is a valid boolean and return the result.
    isValidBoolean(boolean) {
        return typeof boolean == typeof true;
    } */

    /*     deleteDirectoryRecursive(directoryPath) {
        if (fs.existsSync(directoryPath)) {
            fs.readdirSync(directoryPath).forEach(file => {
                const curPath = path.join(directoryPath, file);
                if (fs.lstatSync(curPath).isDirectory()) { // Recursive.
                    this.deleteDirectoryRecursive(curPath);
                } else { // Delete file.
                    fs.unlinkSync(curPath);
                }
            });
            fs.rmdirSync(directoryPath);
        }
    }
 */
/*     updateFile(targetPath, file) {
        fs.writeFileSync(targetPath, JSON.stringify(file, null, 2));
    } */

/*     deleteFile(targetPath) {
        fs.unlinkSync(targetPath);
    } */

    /*     getAllDirectories(targetPath) {
        return fs.readdirSync(targetPath, { withFileTypes: true })
            .filter(dirent => dirent.isDirectory())
            .map(dirent => dirent.name);
    } */
    /* const url = require('url'); */

    /* SetupService,  */